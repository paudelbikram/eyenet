var sajilonet;(()=>{"use strict";var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ActivationFunction:()=>s,ArgumentType:()=>l,BinaryOperation:()=>w,BinaryStep:()=>i,Linear:()=>n,Matrix:()=>A,MatrixOperationType:()=>c,NeuralNet:()=>I,NeuralNetConfig:()=>d,OperationArgument:()=>T,ReLu:()=>o,Sigmoid:()=>r,Tanh:()=>h,TrainingConfig:()=>p,UnaryOperation:()=>u});class s{constructor(e,t,s){this.name=e,this.activate=t,this.deactivate=s}}class i extends s{constructor(){super("BinaryStep",(e=>e>=0?1:0),(e=>0))}}class r extends s{constructor(){super("Sigmoid",(e=>1/(1+Math.exp(-e))),(e=>e*(1-e)))}}class n extends s{constructor(){super("Linear",(e=>e),(e=>1))}}class o extends s{constructor(){super("ReLu",(e=>Math.max(0,e)),(e=>e>0?1:0))}}class h extends s{constructor(){super("Tanh",(e=>(Math.exp(e)-Math.exp(-e))/(Math.exp(e)-Math.exp(-e))),(e=>1-a**2))}}class p{static build(e,t){return new p(e,t)}constructor(e,t){this.learningRate=e,this.epoch=t}}class d{static build(e,t){return new d(e,t)}constructor(e,t){this.layers=e,this.activationFunction=t}}class l{static SCALAR=new l("SCALAR");static MATRIX=new l("MATRIX");static FUNCTION=new l("FUNCTION");constructor(e){this.name=e}}class w{constructor(e,t,s,i){this.leftOperationArgument=e,this.operationType=t,this.rightOperationArgument=s,this.resultingArgument=i}}class c{static DOT_PRODUCT=new c("DOT_PRODUCT");static ELEMENT_WISE_ADDITION=new c("ELEMENT_WISE_ADDITION");static ELEMENT_WISE_FUNCTION=new c("ELEMENT_WISE_FUNCTION");static ELEMENT_WISE_SUBSTRACTION=new c("ELEMENT_WISE_SUBSTRACTION");static ELEMENT_WISE_MULTIPLICATION=new c("ELEMENT_WISE_MULTIPLICATION");static SCALAR_MULTIPLICATION=new c("SCALAR_MULTIPLICATION");static SCALAR_SUBSTRACTION=new c("SCALAR_SUBSTRACTION");static SCALAR_ADDITION=new c("SCALAR_ADDITION");static TRANSPOSE=new c("TRANSPOSE");constructor(e){this.name=e}}class T{constructor(e,t,s){this.argumentName=e,this.argumentType=t,this.argumentValue=s}}class u{constructor(e,t,s){this.argument=e,this.operationType=t,this.resultingArgument=s}}class A{constructor(e,t){this.rows=parseInt(e),this.cols=parseInt(t),this.data=[];for(let e=0;e<this.rows;e++){this.data[e]=[];for(let t=0;t<this.cols;t++)this.data[e][t]=0}}static fromArray(e){let t=new A(e.length,1);for(let s=0;s<e.length;s++)t.data[s][0]=e[s];return t}static subtract(e,t){if(e.rows!==t.rows||e.cols!==t.cols)throw console.error("Can not substract matrices of different size"),new Error("Can not substract matrices of different size");let s=new A(e.rows,e.cols);for(let i=0;i<s.rows;i++)for(let r=0;r<s.cols;r++)s.data[i][r]=e.data[i][r]-t.data[i][r];return s}toArray(){let e=[];for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)e.push(this.data[t][s]);return e}randomize(){for(let e=0;e<this.rows;e++)for(let t=0;t<this.cols;t++)this.data[e][t]=2*Math.random()-1}add(e){if(e instanceof A){if(e.rows!==this.rows||e.cols!==this.cols)throw console.error("Can not add matrices of different size"),new Error("Can not add matrices of different size");for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.data[t][s]+=e.data[t][s]}else for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.data[t][s]+=e}static transpose(e){let t=new A(e.cols,e.rows);for(let s=0;s<e.rows;s++)for(let i=0;i<e.cols;i++)t.data[i][s]=e.data[s][i];return t}static dotProduct(e,t){if(e.cols!==t.rows)throw console.error("Size does not match up for dot product"),new Error("Size does not match up for dot product");let s=new A(e.rows,t.cols);for(let i=0;i<s.rows;i++)for(let r=0;r<s.cols;r++){let a=0;for(let s=0;s<e.cols;s++)a+=e.data[i][s]*t.data[s][r];s.data[i][r]=a}return s}multiply(e){if(e instanceof A){if(e.rows!==this.rows||e.cols!==this.cols)throw console.error("Can not multiply matrices of different size"),new Error("Can not multiply matrices of different size");for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.data[t][s]*=e.data[t][s]}else for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)this.data[t][s]*=e}map(e){for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++){let i=this.data[t][s];this.data[t][s]=e(i)}}static map(e,t){let s=new A(e.rows,e.cols);for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++){let a=e.data[i][r];s.data[i][r]=t(a)}return s}deepCopy(){let e=new A(this.rows,this.cols);for(let t=0;t<this.rows;t++)for(let s=0;s<this.cols;s++)e.data[t][s]=this.data[t][s];return e}print(){console.table(this.data)}}class I{constructor(e){if(e.layers.length<3)throw console.error("Neural Net needs at least 3 layers [input layer, hidden layer, and output layer]"),new Error("Neural Net needs at least 3 layers [input layer, hidden layer, and output layer]");this.inputNodes=e.layers[0],this.outputNodes=e.layers[e.layers.length-1],this.activationFunction=e.activationFunction,this.weights=[],this.bias=[],this.isTrained=!1;for(let t=0;t<e.layers.length-1;t++){let s=new A(e.layers[t+1],e.layers[t]);s.randomize(),this.weights.push(s);let i=new A(e.layers[t+1],1);i.randomize(),this.bias.push(i)}}deepCopyArrayOfMatrices(e){const t=[];for(let s=0;s<e.length;s++)t[s]=e[s].deepCopy();return t}predict(e,t=!1){let s=[],i=A.fromArray(e);for(let e=0;e<this.weights.length;e++){let r=i.deepCopy();i=A.dotProduct(this.weights[e],i);let a=i.deepCopy();t&&s.push(new w(new T("weight",l.MATRIX,this.weights[e].deepCopy()),c.DOT_PRODUCT,new T("X",l.MATRIX,r),new T("weight_DOT_PRODUCT_X",l.MATRIX,a))),i.add(this.bias[e]);let n=i.deepCopy();t&&s.push(new w(new T("weightedLayer",l.MATRIX,a),c.DOT_PRODUCT,new T("bias",l.MATRIX,this.bias[e].deepCopy()),new T("layerAfterBias",l.MATRIX,n))),i.map(this.activationFunction.activate),t&&s.push(new w(new T("activation",l.FUNCTION,this.activationFunction.activate.toString()),c.ELEMENT_WISE_FUNCTION,new T("layerAfterBias",l.MATRIX,n),new T("Y",l.MATRIX,i.deepCopy())))}return t?[i.toArray(),s]:i.toArray()}fit(e,t,s=new Set){let i=new Map,r=new Set([0,1,2,e.length-3,e.length-2,e.length-1]);for(let a=0;a<t.epoch;a++){let n=this.deepCopyArrayOfMatrices(this.weights),o=this.deepCopyArrayOfMatrices(this.bias),h=new Map;for(let i=0;i<e.length;i++){let n=e[i],o=this.deepCopyArrayOfMatrices(this.weights),p=this.deepCopyArrayOfMatrices(this.bias),d=this.train(n.X,n.Y,t.learningRate);s.has(a)&&r.has(i)&&h.set(i,{weightBefore:o,biasBefore:p,feedforward:d.feedforward,backpropagation:d.backpropagation,weightAfter:this.deepCopyArrayOfMatrices(this.weights),biasAfter:this.deepCopyArrayOfMatrices(this.bias)})}s.has(a)&&i.set(a,{weightBefore:n,biasBefore:o,weightAfter:this.deepCopyArrayOfMatrices(this.weights),biasAfter:this.deepCopyArrayOfMatrices(this.bias),trainingData:h})}return this.isTrained=!0,i}train(e,t,s){let i=[],r=[],a=A.fromArray(e),n=[];n.push(a);for(let e=0;e<this.weights.length;e++){let t=[],s=A.dotProduct(this.weights[e],n[n.length-1]),r=s.deepCopy();t.push(new w(new T("weight",l.MATRIX,this.weights[e].deepCopy()),c.DOT_PRODUCT,new T("X",l.MATRIX,n[n.length-1].deepCopy()),new T("weight_DOT_PRODUCT_X",l.MATRIX,r))),s.add(this.bias[e]);let a=s.deepCopy();t.push(new w(new T("weightedInput",l.MATRIX,r),c.ELEMENT_WISE_ADDITION,new T("bias",l.MATRIX,this.bias[e].deepCopy()),new T("weightedInput_ADD_bias",l.MATRIX,a))),s.map(this.activationFunction.activate),t.push(new w(new T("activation",l.FUNCTION,this.activationFunction.activate.toString()),c.ELEMENT_WISE_FUNCTION,new T("inputWithBias",l.MATRIX,a),new T("activatedInput",l.MATRIX,s.deepCopy()))),i.push([t]),n.push(s)}let o=n[n.length-1],h=A.fromArray(t),p=A.subtract(h,o),d=[];d.push(new w(new T("Y",l.MATRIX,h.deepCopy()),c.ELEMENT_WISE_SUBSTRACTION,new T("calculatedY",l.MATRIX,o.deepCopy()),new T("error",l.MATRIX,p.deepCopy()))),r.push(d);let I=[],y=A.map(o,this.activationFunction.deactivate),C=y.deepCopy();I.push(new w(new T("deactivation",l.FUNCTION,this.activationFunction.deactivate.toString()),c.ELEMENT_WISE_FUNCTION,new T("calculatedY",l.MATRIX,o.deepCopy()),new T("gradient",l.MATRIX,C))),y.multiply(p);let f=y.deepCopy();I.push(new w(new T("gradient",l.MATRIX,C),c.ELEMENT_WISE_MULTIPLICATION,new T("error",l.MATRIX,p.deepCopy()),new T("gradient_MULTIPLY_error",l.MATRIX,f))),y.multiply(s),I.push(new w(new T("gradientAfterError",l.MATRIX,f),c.SCALAR_MULTIPLICATION,new T("learningRate",l.SCALAR,s),new T("gradientAfterLearningRate",l.MATRIX,y.deepCopy())));let g=A.transpose(n[n.length-2]);I.push(new u(new T("outputOfLastHiddenLayer",l.MATRIX,n[n.length-2].deepCopy()),c.TRANSPOSE,new T("TRANSPOSE_lastHiddenLayer",l.MATRIX,g.deepCopy())));let M=A.dotProduct(y,g);I.push(new w(new T("gradientAfterLearningRate",l.MATRIX,y.deepCopy()),c.DOT_PRODUCT,new T("transposeOfLastHiddenLayer",l.MATRIX,g.deepCopy()),new T("delta",l.MATRIX,M.deepCopy())));let R=this.weights[this.weights.length-1];this.weights[this.weights.length-1].add(M),I.push(new w(new T("weight",l.MATRIX,R.deepCopy()),c.ELEMENT_WISE_ADDITION,new T("delta",l.MATRIX,M.deepCopy()),new T("newWeight",l.MATRIX,this.weights[this.weights.length-1].deepCopy())));let E=this.bias[this.bias.length-1];this.bias[this.bias.length-1].add(y),I.push(new w(new T("bias",l.MATRIX,E.deepCopy()),c.ELEMENT_WISE_ADDITION,new T("gradient",l.MATRIX,y.deepCopy()),new T("newBias",l.MATRIX,this.bias[this.bias.length-1].deepCopy()))),r.push(I);let O=p;for(let e=this.weights.length-1;e>0;e--){let t=A.transpose(this.weights[e]),i=[];i.push(new u(new T("weight",l.MATRIX,this.weights[e].deepCopy()),c.TRANSPOSE,new T("transposeOfWeight",l.MATRIX,t.deepCopy())));let a=O.deepCopy();O=A.dotProduct(t,O),i.push(new w(new T("transposeOfWeight",l.MATRIX,t.deepCopy()),c.DOT_PRODUCT,new T("hiddenError",l.MATRIX,a.deepCopy()),new T("transposeOfWeight_DOT_hiddenError",l.MATRIX,O.deepCopy())));let o=A.map(n[e],this.activationFunction.deactivate),h=o.deepCopy();i.push(new w(new T("deactivation",l.FUNCTION,this.activationFunction.deactivate.toString()),c.ELEMENT_WISE_FUNCTION,new T("layerOutput",l.MATRIX,n[e].deepCopy()),new T("gradient",l.MATRIX,o.deepCopy()))),o.multiply(O);let p=o.deepCopy();i.push(new w(new T("hiddenGradient",l.MATRIX,h.deepCopy()),c.ELEMENT_WISE_MULTIPLICATION,new T("hiddenError",l.MATRIX,O.deepCopy()),new T("gradientAfterError",l.MATRIX,p))),o.multiply(s),i.push(new w(new T("gradientAfterError",l.MATRIX,p),c.ELEMENT_WISE_MULTIPLICATION,new T("learningRate",l.SCALAR,s),new T("gradientAfterLearningRate",l.MATRIX,o.deepCopy())));let d=A.transpose(n[e-1]);i.push(new u(new T("layerOutput",l.MATRIX,n[e-1].deepCopy()),c.TRANSPOSE,new T("transposeOfLayerOutput",l.MATRIX,d.deepCopy())));let I=A.dotProduct(o,d);i.push(new w(new T("hiddenGradient",l.MATRIX,o.deepCopy()),c.DOT_PRODUCT,new T("transposeOfLayerOutput",l.MATRIX,d.deepCopy()),new T("delta",l.MATRIX,I.deepCopy())));let y=this.weights[e-1],C=this.bias[e-1];this.weights[e-1].add(I),i.push(new w(new T("previousWeight",l.MATRIX,y.deepCopy()),c.ELEMENT_WISE_ADDITION,new T("delta",l.MATRIX,I.deepCopy()),new T("newWeight",l.MATRIX,this.weights[e-1].deepCopy()))),this.bias[e-1].add(o),i.push(new w(new T("previousBias",l.MATRIX,C.deepCopy()),c.ELEMENT_WISE_ADDITION,new T("hiddenGradient",l.MATRIX,o.deepCopy()),new T("newBias",l.MATRIX,this.bias[e-1].deepCopy()))),r.push(i)}return{feedforward:i,backpropagation:r}}}sajilonet=t})();